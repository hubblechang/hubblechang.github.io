---
title: 消息队列
categories: 
- 中间件
---
## 消息队列的应用
复杂业务数据交互的异步传递时，消息队列作为专门针对消息接收、存储、转发的程序。基本思想是**利用高效可靠的消息传递机制进行异步的数据传输**。主要作用包括：
1. 异步通信：比如订火车票，可能排队很久才真正买到
2. 削峰/限流：将短时间高并发产生的事务存储在消息队列中，消费者实例根据自己能力消费
3. 降低系统耦合性：将生产者和消费者解除耦合了，生产者和消费者无需知道对方的处理流程，对于新增业务，只要与该类消息相关，订阅该消息即可。
4. 顺序保证：保证了消息的顺序消费，比如按时间等
5. 延时/定时处理：由于RabbitMQ本身不带延时队列，可以用死信队列实现延时队列的功能。

## 使用中存在的问题

### 消息顺序性保证

RabbitMQ所提供的单个队列数据是存储在单个broker节点上的，在开启镜像队列的情况下，镜像的队列也只作为消息副本而存在，服务依然由主队列提供。但存在多个消费者时，无法保证消费者处理消息的顺序。
对于需要强制顺序的消息，使用同一个MQ队列，并且针对单个队列只开启一个消费者消费（保证并发处理时的顺序性，多线程同理）。由此引发的单个队列吞吐下降的问题，可以采取kafka的设计思想，针对单一任开启一组多个队列，将需要顺序的消息按照其固定标识（例如：ID）进行路由，分散到这一组队列中，相标识的消息进入到相同的队列，单个队列使用单个消费者消费，这样即可以保证消息的顺序与吞吐。

### 避免消息丢失
消息中间件一般都有消息发送确认机制（ACK）, 对于客户端来说，只要配置好消息发送需要ACK确认，就可以根据返回的结果来判断消息是否成功发送到中间件中。
+ 开启MQ的ACK（或confirm）机制，直接获知消息发送结果
+ 开启消息队列的持久化机制（落盘，如果需要特殊设置的话）
+ 中间件本身做好高可用部署
+ 消息发送失败补偿设计（重试等）
补偿方案包含：
+ 消息失败重试机制（发送失败，继续重发，可以设置重试上限）
+ 如果依然失败，根据消息重要性，选择降级方案：直接丢弃或者降级到其他中间件或载体（同时需要相应降级补偿推送或消费设计）
RabbitMQ消息接收与保存：
+ RabbitMQ 消息发送可以开启发送者confirm模式，所有消息是否发送成功都会通知发送者；
+ 需要开启队列消息持久化保证消息落盘；
+ RabbitMQ通过镜像队列来保证消息队列的高可用，但是镜像队列只有Master提供服务，其他slave只提供份服务；
+ master宕机会从slave中选择一个成为新的master提供服务；
+ master的生产与消费的最新状态都会广播到slave；

**（1）积压消息保存时效问题**
Kafka对于topic下的数据，有容量上限、时间上限两种消息存储上限规则，触发其中任何一个规则，都会删淘汰之前的消息。这个尤其需要注意。
RocketMQ，消息在服务器存储时间也有上限，达到上限的消息将会被删除。也需要做相应的考量。
受持久化磁盘容量的影响，存储积压的数据不能超过磁盘的上限。
如果业务消费有异常，需要给足充足的冗余量，避免因为消费不及时而丢失数据。
**（2）消费者消费消息不丢失：**
消息消费时候，也要开启相应的ACK机制，消息消费成功即ACK（对于Kafka就是更新消费的offset）；
对于RocketMQ这种有消息重新消费设计的，需要设置最大消费次数，尝试失败的消息重复消费。
**（3）消息ACK带来两个问题：**
消息消费失败如果不能ACK可能会导致消息消费无限阻塞在某条消息处；
消息失败重新消费导致消息消费重复。
**（4）无限阻塞的问题，可以参考RocketMQ消费失败的重试机制，对消息重试做一定的设计：**
在消息体上设计重试次数的属性，消费失败的消息增加重试次数后重新发送到中间件，等待下一次消费，本消费成功发回消息直接ACK。
消息重试次数达到上限之后，如果仍不能成功，则启用降级方案，将消息存储到异常信息持久化载体如DB。
手动或者定时任务补偿处理失败的消息。

###  消息的重复问题（消息幂等）
核心是使用唯一标识，来标记某条消息是否已经处理过。
+ 使用数据库自增主键，或者唯一键来保证数据不会重复变动；
+ 使用中间状态，以及状态变动有序性来判断业务是否以已经被处理；
+ 利用一张日志表来记录已经处理成功的消息的 ID，如果新到的消息 ID 已经在日志表中，那么就不再处理这条消息；
+ 或者消息唯一标识，在Redis等NoSQL中维护一个处理缓存，判断是否已经处理过；
+ 如果消费者业务流程比较长，则需要开发者自己保证整个业务消费逻辑中数据处理的事务性。

**雪花算法**是分布式情况下生成唯一键的一种有效方法
+ 1：最高 1 位是符号位，固定值 0，表示id 是正整数
+ 41：接下来 41 位存储毫秒级时间戳，2^41/(1000606024365)=69，大概可以使用 69 年。
+ 10：再接下 10 位存储机器码，包括 5 位 datacenterId 和 5 位 workerId。最多可以部署 2^10=1024 台机器。
+ 12：最后 12 位存储序列号。同一毫秒时间戳时，通过这个递增的序列号来区分。即对于同一台机器而言，同一毫秒时间戳下，可以生成 2^12=4096 个不重复 id。

###  消息积压处理
通常我们在引入消息中间件的时候，已经会评估与测试消息消费的生产与消费速率，尽量使其达到平衡。但业务也有一些不可预知的突发情况，可能会造成消息的大量积压。出现后，处理方法：
**（1）临时紧急扩容**

+ 通过增加消费脚本的方式，提升消费速率，如果下游没有限制的话，可以很快的减少消息积压。
+ 如果消费者下游数据处理能力有限，我们可以考虑建立临时队列，通过临时脚本，将消息快速转移到临时队列，优先保证线上业务能顺利贯通，而后开启更多的消费脚本处理积压的数据。（顺序消息需要额外处理，并保证最终处理的顺序）
+ 优化消费脚本的处理速度，突破下游限制，如果有可能，可以考虑批量处理，下游扩容等方式。

**（2）消息积压预防**

+ 做好业务设计与降级，避免产生无效消息占用资源
+ 根据消息积压程度，动态增减消费者数量，减少消息积压
+ 做好消息积压处理紧急预案，异常情况根据预案设计，迅速针对处理

###  延迟消息处理
RabbitMQ实现延迟消息通常有两个方案：
+ 一是创建一个消息延迟死信队列，搭配一个死信转发队列来实现消费延时。但是该方式如果前一个消息没达到TTL时间，后一个消息即便达到了，也不会被转发到转发队列中；
+ 另一个是使用延时Exchange插件（rabbitmq_delayed_message_exchange），消息在达到TTL之后才会转发到对应的队列中并被消费。



## 扩展

### JMS和AMQP

1. JMS(JAVA Message Service,java 消息服务)
JMS的客户端之间可以通过JMS服务进行异步的消息传递，JMS API是一个消息服务的标准/规范，允许程序通过**JavaEE平台**创建、发送、接收和读取消息，设计模式包含工厂模式。JMS可以传递六种消息：
   + Message: This represents a message without a message body.
   + StreamMessage: A message whose body contains a stream of Java primitive types(基本类型). It is written and read sequentially.
   + MapMessage: A message whose body contains a set of name/value pairs. The order of entries is not defined.
   + TextMessage: A message whose body contains a Java string...such as an XML message.
   + ObjectMessage: A message whose body contains a serialized Java object.
   + BytesMessage: A message whose body contains a stream of uninterpreted bytes.
JMS包含点到点和发布/订阅两种消息模型

2. AMQP
Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 级消息队列协议（二进制应用层协议），是**应用层协议的一个开放标准**，为面向消息的中间件设计，兼容 JMS。有5种消息模型，只支持`byte[]`类型的消息。




## 参考
1. [得物技术](https://mp.weixin.qq.com/s/60V3eoV_jFxBwsK6NiHM-g)
2. [JavaGuide-消息队列](https://javaguide.cn/high-performance/message-queue/message-queue.html#jms-vs-amqp)
3. [Oracle-JMS简介](https://www.oracle.com/technical-resources/articles/java/intro-java-message-service.html)