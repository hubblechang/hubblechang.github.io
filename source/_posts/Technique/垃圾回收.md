---
title: 垃圾回收
categories: 
- JVM
---
JVM GC调优：
+ 如果应用程序的数据集较小（最多大约 100 MB），则使用选项 -XX:+UseSerialGC 选择串行收集器。
+ 如果应用程序将在单个处理器上运行并且没有暂停时间要求，则使用选项 -XX:+UseSerialGC 选择串行收集器。
+ 如果 (a) 峰值应用程序性能是第一优先级并且 (b) 没有暂停时间要求或可以接受一秒或更长的暂停，则让 VM 选择收集器或使用 -XX:+UseParallelGC 选择并行收集器。
+ 如果响应时间比总体吞吐量更重要，并且垃圾收集暂停必须保持较短，则使用 -XX:+UseG1GC 选择大多数并发收集器。
+ 如果响应时间是高优先级，则使用 -XX:UseZGC 选择完全并发的收集器。
## G1 GC
G1垃圾收集器适用于扩展到大量内存的多处理器计算机，旨在实现GC Pause和吞吐量之间的最佳平衡，使用场景包括：
+ 堆大小高达数十 GB 或更大，超过 50% 的 Java 堆被实时数据占用。
+ 对象分配和升级的速率可能随时间发生显着变化。
+ 堆中存在大量碎片。
+ 可预测的暂停时间目标不超过几百毫秒，避免长时间的垃圾收集暂停。

G1是默认的垃圾收集器，显式启用可以使用一下命令
```bash
-XX:+UseG1GC
```

G1 将堆划分为一组大小相等的堆区域，每个堆区域都是连续的虚拟内存范围，如图所示。区域是内存分配和内存回收的单位。在任何给定时间，每个区域都可以是空的（浅灰色），或者分配给特定的一代，无论是年轻的还是年长的。当内存请求到来时，内存管理器会分发空闲区域。内存管理器将它们分配给一代，然后将它们作为可用空间返回给应用程序，应用程序可以在其中分配自己。

{% asset_img G1.png G1 Collector %}

1. 对象优先在Eden区分配
2. 大对象直接进入老年代
3. 长期存活的对象进入老年代

在较高层面上，G1 收集器在两个阶段之间交替。 young-only 阶段包含垃圾收集，逐渐用老年代中的对象填充当前可用的内存。在 Space-reclamation 空间回收阶段，G1 除了处理年轻代之外，还逐步回收老年代的空间。然后，循环以young-only 阶段重新开始

G1 在调整 Java 堆大小时遵循标准规则，使用 -XX:InitialHeapSize 作为最小 Java 堆大小，-XX:MaxHeapSize 作为最大 Java 堆大小，-XX:MinHeapFreeRatio 为可用内存的最小百分比，-XX:MaxHeapFreeRatio 为确定调整大小后可用内存的最大百分比。 G1 收集器仅在 Remark 和 Full GC 暂停期间考虑调整 Java 堆大小。该进程可能会向操作系统释放内存或从操作系统分配内存。

### Young GC
Young-Only Phase Generation Sizing

Young GC（年轻代回收）：主要针对年轻代区域的垃圾回收，包括Eden区和Survivor区。当所有Eden区使用率达到最大阀值（默认60%）或者G1计算出来的回收时间接近用户设定的最大暂停时间时，会触发一次Young GC，回收Eden区和Survivor区，复制移动到另外的Survivor幸存者（年龄+1）或Old老年代区（提前晋升的）

使用记忆集（跨代对象引用）、卡表（每个region都有，记录引用自己的卡页）、写屏障（并发安全）

G1 总是在正常年轻代集合结束时为下一个变异阶段调整年轻代的大小。这样，G1 就可以满足根据实际暂停时间的长期观察使用 -XX:MaxGCPauseTimeMillis 和 -XX:PauseTimeIntervalMillis 设置的暂停时间目标。它考虑了规模相似的年轻一代撤离所需的时间。这包括诸如在收集期间必须复制多少对象以及这些对象的互连程度等信息。
如果没有其他限制，则 G1 会在 -XX:G1NewSizePercent 和 -XX:G1MaxNewSizePercent 确定的值之间自适应调整年轻代大小以满足暂停时间。有关如何修复长时间暂停的详细信息，请参阅垃圾优先垃圾收集器调整。

### Mixed GC

Mixed GC（混合回收）：Mixed GC是G1垃圾回收器独有的，也称混合回收，针对年轻代和部分老年代区域的垃圾回收。当老年代的占有率达到阀值（默认45%）或年轻代被分配大对象时，会触发一次Mixed GC，回收所有年轻代和一部分老年代区（选取的策略是垃圾对象最多的老年代区域，确保释放更多内存空间，即回收价值高的），控制最大暂停时间。

#### 前驱知识
三色标记、SATB和GC Root
1. 三色标记：
   + 白色-垃圾对象（所有对象的初始状态，表示不在GC Root引用链上）
   + 灰色-待处理对象（在GC Root引用链上，单该对象的所有引用的对象还未标记过，是一个过渡色）
   + 黑色-存活对象（对象在GC Root引用链上，并且该对象所有引用的对象都被标记过）
2. SATB原始快照
    + 在标记开始时，创建一个原始快照，记录当前所有存活的对象
    + 在标记执行过程中，新创建的对象，直接标记为黑色
    + 在标记执行过程中，出现对象引用赋值操作，G1垃圾回收器采用写前屏障技术，将引用的对象放入一个待处理的SATB队列，该队列是每个线程独有的，最终会汇总到全局的SATB队列
3. GC Root包含的类
    + Class - 由系统类加载器(system class loader)加载的对象，这些类是不能够被回收的，他们可以以静态字段的方式保存持有其它对象。我们需要注意的一点就是，通过用户自定义的类加载器加载的类，除非相应的Java.lang.Class实例以其它的某种（或多种）方式成为roots，否则它们并不是roots，.
    + Thread - 活着的线程
    + Stack Local - Java方法的local变量或参数
    + JNI Local - JNI方法的local变量或参数
    + JNI Global - 全局JNI引用
    + Monitor Used - 用于同步的监控对象
    + Held by JVM - 用于JVM特殊目的由GC保留的对象，但实际上这个与JVM的实现是有关的。可能已知的一些类型是：系统类加载器、一些JVM知道的重要的异常类、一些用于处理异常的预分配对象以及一些自定义的类加载器等。

#### GC流程
1. 初始标记：STW，GC Root跟对象直接相关联的对象，三色
2. 并发标记：用户线程执行，对灰色对象处理，三色，可能有漏标（存活回收，使用SATB解决）、多标（垃圾存活）
3. 最终标记：修正并发标记期间产生变动的对象，STW，将所有线程的SATB队列合并到全局SATB队列，逐一消费。在全局SATB队列中的对象，默认按照黑色存活对象处理，同时处理它们引用的其它对象。
4. 清理：G1垃圾回收器会整理Region区域，调整对应的记忆集，若识别到某个Region不存在任何存活对象时，会直接清理掉该Region，释放内存
5. 转移：STW，将某一个Region区域存活的对象复制到另一个Region，区域选择->对象复制转移->更新引用关系




在空间回收阶段，G1 尝试在一次垃圾收集暂停中最大化老年代中回收的空间量。年轻代的大小设置为允许的最小值，通常由 -XX:G1NewSizePercent 确定。
在该阶段的每个混合收集开始时，G1从收集集候选中选择一组区域以添加到收集集中。这组额外的老年代区域由三部分组成：
+ 确保疏散进度的最低限度的老年代区域集。这组老年代区域由收集组候选中的区域数量除以空间回收阶段的长度（由 -XX:G1MixedGCCountTarget 确定）来确定。
+ 如果 G1 预测在收集最小集合后还有剩余时间，则收集集合候选中的其他老年代区域。添加老年代区域，直到预计使用 80% 的剩余时间。
+ 一组可选的收集集区域，在其他两部分被疏散后，G1 逐步疏散，并且在此暂停期间还剩下时间。
前两组区域在初始收集过程中收集，可选收集集中的其他区域适合剩余的暂停时间。该方法确保了空间回收进度，同时提高了由于可选收集集的管理而保持暂停时间和最小开销的概率。
当收集集候选区域中可回收的剩余空间量小于-XX:G1HeapWastePercent 设置的百分比时，Space-Reclamation 阶段结束。

### Periodic GC (contain full GC)
如果由于应用程序不活动而长时间没有垃圾收集，VM 可能会长时间保留大量未使用的内存，这些内存可以在其他地方使用。为了避免这种情况，可以使用 -XX:G1PeriodicGCInterval 选项强制 G1 定期进行垃圾回收。此选项确定 G1 考虑执行垃圾收集的最小间隔（以毫秒为单位）。如果自任何先前的垃圾收集暂停以来已经过去了这个时间量，并且没有正在进行的并发循环，则 G1 会触发额外的垃圾收集，并可能产生以下影响：
+ 在 Young-Only 阶段：G1 使用并发启动暂停启动并发标记，或者如果指定了 -XX:-G1PeriodicGCInvokesConcurrent，则使用 Full GC。
+ 在空间回收阶段：G1 继续空间回收阶段，触发适合当前进度的垃圾收集暂停类型。
-XX:G1PeriodicGCSystemLoadThreshold 选项可用于细化是否触发垃圾收集：如果 JVM 主机系统（例如容器）上的 getloadavg() 调用返回的平均一分钟系统负载值高于此值值，不会运行定期垃圾收集。

### 参数设置
`-XX:MaxGCPauseMillis=200`：最大暂停时间的目标。
`-XX:GCPauseTimeInterval=<ergo>`：最大暂停时间间隔的目标。默认情况下，G1 不设定任何目标，允许 G1 在极端情况下连续执行垃圾收集。
`-XX:ParallelGCThreads=<ergo>`：垃圾收集暂停期间用于并行工作的最大线程数。
`-XX:ConcGCThreads=<ergo> `：用于并发工作的最大线程数。
`-XX:G1HeapRegionSize=<ergo> `：Region区域的大小。默认值基于最大堆大小，经计算可渲染大约 2048 个区域。大小必须是 2 的幂，有效值为 1 到 32 MB。
`-XX:G1NewSizePercent=5-XX:G1MaxNewSizePercent=60`：年轻代的总大小，在这两个值之间变化
`-XX:G1HeapWastePercent=5`：集合集候选中允许的未回收空间（以百分比表示）。如果收集集候选中的可用空间低于该值，G1 停止空间回收阶段。

## CMS GC

## 参考
1. [Oracle-Garbage Collector](https://docs.oracle.com/en/java/javase/17/gctuning/garbage-first-g1-garbage-collector1.html#GUID-0394E76A-1A8F-425E-A0D0-B48A3DC82B42)
2. [G1-CSDN-Highly Recommended](https://blog.csdn.net/mm1274889792/article/details/139030273)
3. [G1-MeituanTech](https://tech.meituan.com/2016/09/23/g1.html)