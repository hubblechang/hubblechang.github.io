---
title: 快Star一面
categories: 
- 面试
---
# 手撕
1. 手写ReentrantLock
2. 全排列，回溯经典手撕
# 八股
1. TCP最多能建立多少个连接
TCP能建立的连接取决于<b>IP数</b>和<b>端口数</b>，连接个数为<b>IP数 * 端口数</b>，对 IPv4，客户端的IP数最多为$2^{32}$，一台电脑共有65536个端口，为$2^{16}$个。则在不考虑服务器的内存和文件句柄资源的情况下，理论上一个服务端进程最多能支持约为$2^{48}$个。
2. TCP的CLOSE-WAIT和TIME-WAIT状态
TCP挥手中，Server收到Client第一次发送的FIN包并回复ACK后进入CLOSE-WAIT状态。Server向Client发送FIN包后，Client进入TIME-WAIT状态。
3. TIME-WAIT时间是多少，如果设计得过长过短会发生什么
    + TIME-WAIT时间为2MSL，绝对时间不同系统不一样，Windows为2分钟，Ubuntu/Centos为1分钟。
    + 过断
        - 数据包重传问题：如果TIME-WAIT时间过短，可能会导致在关闭连接后，网络中仍然存在一些延迟的数据包。这些数据包可能会在连接关闭后到达，而由于TIME-WAIT时间过短，这些<b>数据包可能会被错误地认为是新的连接的数据包，从而导致数据混乱或错误</b>。
    + 过长
        - 资源占用：每个处于TIME-WAIT状态的连接都会<b>占用一定的系统资源，包括内存和端口号</b>。如果TIME-WAIT时间过长，会导致系统资源被长时间占用，影响系统的性能和可扩展性。
        - 连接延迟：在某些高并发或短连接的场景下，如果TIME-WAIT时间过长，可能会导致新的连接需要等待较长时间才能使用相同的端口，从而<b>增加了连接的延迟</b>。
4. 读写锁、锁升级、锁降级

锁升级，锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。

> 偏向锁:共享资源首次被访问时，JVM会对该共享资源对象做一些设置，比如将对象头中是否偏向锁标志位置为1，对象头中的线程ID设置为当前线程ID（注意：这里是操作系统的线程ID），后续当前线程再次访问这个共享资源时，会根据偏向锁标识跟线程ID进行比对是否相同，比对成功则直接获取到锁，进入临界区域（就是被锁保护，线程间只能串行访问的代码），这也是synchronized锁的可重入功能。

> 轻量级锁：当多个线程同时申请共享资源锁的访问时，这就产生了竞争，JVM会先尝试使用轻量级锁，以CAS方式来获取锁（一般就是自旋加锁，不阻塞线程采用循环等待的方式），成功则获取到锁，状态为轻量级锁，失败（达到一定的自旋次数还未成功）则锁升级到重量级锁。

> 重量级锁：如果共享资源锁已经被某个线程持有，此时是偏向锁状态，未释放锁前，再有其他线程来竞争时，则会升级到重量级锁，另外轻量级锁状态多线程竞争锁时，也会升级到重量级锁，重量级锁由操作系统来实现，所以性能消耗相对较高。

锁降级,锁分为读锁 (共享锁)、写锁（排他锁）两种：
+ 一个线程获取了写锁，其他线程无法获取写锁、读锁，进行阻塞；
+ 一个线程获取了读锁，其他线程无法获取写锁（进行阻塞），但是可以获取读锁；

> 如果只使用写锁，那么释放写锁之后，其他线程就会获取到写锁或读锁，使用锁降级可以在释放写锁前获取读锁，这样其他的线程就只能获取读锁，对这个数据进行读取，但是不能获取写锁进行修改，只有当前线程释放了读锁之后才可以进行修改。

+ 相对于一直使用写锁，锁降级可以减少其他读线程的阻塞。