---
title: 20240802
categories: 
- 复习
---

# Java IO
一个进程的地址空间被分为<b>用户空间</b>和<b>内核空间</b>，IO操作必须依赖内核空间。


> linux的虚拟空4G，分为内核空间和用户空间，其中最开的（3G）0x00000000-0xBFFFFFFF为各个进程使用，也叫用户空间，最高处的（1G）0xC0000000-0xFFFFFFFF作为内核空间供内核使用,Linux内核空间由系统内的所有进程共享。于是，从具体进程的角度来看，每个进程可以拥有4G字节的虚拟地址空间(也叫虚拟内存)。其中每个进程有各自的私有用户空间（0～3G），这个空间对系统中的其他进程是不可见的。最高的1GB内核空间则为所有进程以及内核所共享。

## 发起IO调用后，两步骤：
1. 内核等待IO设备准备好数据
2. 内核将数据从内核空间拷贝到用户空间

## 常见IO模型
### BIO
同步阻塞模型，程序发起read调用后，一直阻塞，直到内核把数据拷贝到用户空间。

### NIO
同步非阻塞IO。<b>应用程序会一直发起 read 调用</b>，等待数据从内核空间拷贝到用户空间的这段时间里，线程依然是阻塞的（一直发起 read 调用，不阻塞），直到在内核把数据拷贝到用户空间（这段时间阻塞）。

通过轮询操作避免了一直阻塞，but不断进行IO系统调用轮询数据是否准备好很消耗cpu资源。

#### IO多路复用
线程首先发起 select 调用，询问内核数据是否准备就绪，等内核把数据准备好了，用户线程再发起 read 调用。read 调用的过程（数据从内核空间->用户空间）还是阻塞的

通过减少无效的系统调用，减少了对 CPU 资源的消耗。选择器 (Selector：select、poll、epoll) ，也可以被称为 多路复用器。通过它，只需要一个线程便可以管理多个客户端连接。当客户端数据到了之后，才会为其服务。

### AIO
基于事件和回调机制，应用操作之后直接返回，不会阻塞在那里，当操作系统将数据准备完成，通知相应的线程进行后续的操作。